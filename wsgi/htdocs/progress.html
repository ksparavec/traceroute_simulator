<!DOCTYPE html>
<html>
<head>
    <title>Network Service Reachability Analyzer</title>
    <link rel="stylesheet" href="/css/style.css">
    <script src="/js/mode_title.js"></script>
</head>
<body>
    <div class="container">
        <header>
            <h1>Network Service Reachability Analyzer</h1>
        </header>

        <table id="userInfo" style="width: 100%; margin: 15px 0; border-collapse: collapse; font-size: 14px;">
            <tr>
                <td style="padding: 8px; border: 1px solid #ccc; text-align: left; font-weight: bold;">Mode: <span id="modeDisplay" style="font-weight: normal;">Loading...</span></td>
                <td style="padding: 8px; border: 1px solid #ccc; text-align: right; font-weight: bold;">Authentication Method: <span id="authMethodDisplay" style="font-weight: normal;">Loading...</span></td>
            </tr>
            <tr>
                <td style="padding: 8px; border: 1px solid #ccc; text-align: left; font-weight: bold;">Username: <span id="usernameDisplay" style="font-weight: normal;">Loading...</span></td>
                <td style="padding: 8px; border: 1px solid #ccc; text-align: right; font-weight: bold;">Logged in since: <span id="loginTimestampDisplay" style="font-weight: normal;">Loading...</span></td>
            </tr>
        </table>
        
        <div class="progress-container">
            <div class="progress-bar">
                <div id="progressBar" class="progress-fill" style="width: 0%"></div>
                <div class="progress-text" id="progressText">Initializing test...</div>
            </div>
            <div class="progress-percentage">
                <span id="progressPercent">0</span>%
            </div>
        </div>
        
        <div class="progress-log">
            <div id="progressLog"></div>
        </div>
        
        <div style="text-align: center; margin-top: 20px;">
            <button id="showPdfButton" style="display: none; padding: 12px 24px; font-size: 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s; margin-right: 10px;" 
                    onmouseover="this.style.backgroundColor='#2980b9'" 
                    onmouseout="this.style.backgroundColor='#3498db'" 
                    disabled>
                Show PDF Report
            </button>
        </div>
    </div>

    <script>
    // Get parameters from URL
    const urlParams = new URLSearchParams(window.location.search);
    const runId = urlParams.get('run_id') || urlParams.get('id');  // Support both 'run_id' and 'id'
    const sessionId = urlParams.get('session');
    
    // Track progress using server-provided percent/expected_steps
    let currentProgress = 0;
    let processedPhases = new Set();
    let firstCheckDone = false;
    let pdfRedirectUrl = null;
    let lastMilestoneMessage = 'Initializing...';  // Keep track of last milestone
    
    function updateProgress(percent, status) {
        // Update progress bar - always use the provided percent value
        document.getElementById('progressBar').style.width = percent + '%';
        document.getElementById('progressPercent').textContent = Math.round(percent);
        
        // Only update text if status is provided
        if (status !== null && status !== undefined) {
            document.getElementById('progressText').textContent = status;
        }
    }
    
    function addProgressLogEntry(message, type = 'info') {
        const logDiv = document.getElementById('progressLog');
        const entry = document.createElement('div');
        entry.className = `progress-log-entry ${type}`;
        const timestamp = new Date().toLocaleTimeString();
        entry.textContent = `[${timestamp}] ${message}`;
        logDiv.appendChild(entry);
        // Auto-scroll to bottom to show latest entry
        // Need to scroll the parent container that has the scrollbar
        const scrollContainer = logDiv.parentElement;
        setTimeout(function() {
            scrollContainer.scrollTop = scrollContainer.scrollHeight;
        }, 10);
    }
    
    function getPhaseStatus(phase) {
        // Generate human-readable status from phase name
        const statusMap = {
            // Main test phases
            'START': 'Starting test',
            'parse_args': 'Validating parameters',
            'QUEUED': 'In queue',
            'WAITING_FOR_ENVIRONMENT': 'Waiting for simulator to be available',
            'TRACE_COMPLETE': 'Trace execution completed',
            'SERVICE_TESTS': 'Testing services',
            'PDF_GENERATION': 'Generating PDF report',
            'PHASE1_start': 'Initializing path discovery',
            'PHASE1_path_discovery': 'Discovering network path',
            'PHASE1_trace_load': 'Loading trace data',
            'PHASE1_trace_complete': 'Trace completed',
            'PHASE1_complete': 'Path discovery complete',
            'PHASE2_start': 'Setting up environment',
            'PHASE2_host_list': 'Checking existing hosts',
            'PHASE2_host_setup_start': 'Setting up test hosts',
            'PHASE2_hosts_complete': 'Hosts configured',
            'PHASE2_service_check': 'Checking services',
            'PHASE2_services_start': 'Starting services',
            'PHASE2_complete': 'Environment ready',
            'PHASE3_start': 'Starting reachability tests',
            'PHASE3_complete': 'Initial tests complete',
            'PHASE4_start': 'Testing services',
            'PHASE4_complete': 'Service tests complete',
            'PHASE5_format_output': 'Formatting results',
            'PHASE5_complete': 'Results formatted',
            'TOTAL': 'Test execution complete',
            
            // Cleanup phases
            'cleanup_start': 'Starting cleanup',
            'cleanup_complete': 'Cleanup complete',
            
            // Web request phases
            'web_request_START': 'Initializing request',
            'web_request_execute_trace': 'Executing trace',
            'web_request_network_reachability_test_multi_2_services': 'Testing services',
            'web_request_network_reachability_test_multi_3_services': 'Testing services',
            'web_request_generate_multi_page_pdf': 'Generating PDF report',
            'web_request_generate_share_link': 'Creating share link',
            'web_request_prepare_redirect': 'Preparing results',
            'web_request_TOTAL': 'Request complete',
            
            // PDF generation phases
            'PDF_GEN_PARSE_START': 'Parsing PDF parameters',
            'PDF_GEN_parse_params': 'Processing PDF settings',
            'PDF_GEN_validate_params': 'Validating PDF parameters',
            'PDF_GEN_venv_activate': 'Preparing PDF environment',
            'PDF_GEN_visualize_reachability.py': 'Rendering PDF',
            'PDF_GEN_TOTAL': 'PDF complete',
            
            // KSMS Quick Analysis phases
            'KSMS_QUICK_START': 'Starting quick analysis',
            'KSMS_BULK_SCAN': 'Executing bulk service scan',
            'KSMS_FORMAT_RESULTS': 'Processing scan results',
            'KSMS_PDF_GENERATION': 'Generating summary report',
            
            // Generic phases
            'COMPLETE': 'Test complete!',
            'ERROR': 'Error occurred',
            'FAIL': 'Test failed',
            'FAILED': 'Cancelled'
        };
        
        // For dynamic phases like host_add_source_1, service_22_tcp_started, etc.
        if (phase.startsWith('host_add_source')) {
            return 'Adding source host';
        } else if (phase.startsWith('host_add_dest')) {
            return 'Adding destination host';
        } else if (phase.startsWith('service_') && phase.includes('_started')) {
            return 'Starting service';
        } else if (phase.startsWith('service_') && phase.includes('_exists')) {
            return 'Service exists';
        } else if (phase.startsWith('test_') && phase.includes('_start')) {
            return 'Testing service';
        } else if (phase.startsWith('test_') && phase.includes('_complete')) {
            return 'Service test complete';
        } else if (phase.startsWith('iptables_')) {
            return 'Analyzing firewall rules';
        } else if (phase.startsWith('service_test_')) {
            return 'Running service test';
        } else if (phase.startsWith('service_') && phase.includes('_file_created')) {
            return 'Creating result file';
        } else if (phase.includes('network_reachability_test_multi_')) {
            // Extract number of services
            const match = phase.match(/(\d+)_services/);
            if (match) {
                return `Testing ${match[1]} services`;
            }
            return 'Testing services';
        }
        
        return statusMap[phase] || phase.replace(/_/g, ' ');
    }
    
    // Use Server-Sent Events for real-time progress
    function startProgressStream() {
        if (!runId) {
            addProgressLogEntry('Error: No run ID provided', 'error');
            return;
        }
        
        // Create EventSource connection with both run_id and session
        const eventSource = new EventSource(`/progress-stream?run_id=${runId}&session=${sessionId}`);
        
        eventSource.onmessage = function(event) {
            try {
                const data = JSON.parse(event.data);
                
                // Process all phases that have been seen
                let newPhasesProcessed = false;
                if (data.all_phases && data.all_phases.length > 0) {
                    data.all_phases.forEach(phaseInfo => {
                        const phase = phaseInfo.phase;
                        const details = phaseInfo.details || '';
                        
                        const phaseKey = `${phase}|${details}`; // Unique key including details
                        if (!processedPhases.has(phaseKey)) {
                            processedPhases.add(phaseKey);
                            
                            // Use server-provided percent if available; otherwise derive from counts
                            if (typeof data.percent === 'number') {
                                currentProgress = Math.min(Math.max(data.percent, 0), 100);
                            } else if (typeof data.expected_steps === 'number' && data.expected_steps > 0) {
                                currentProgress = Math.min(99, Math.floor(100 * (data.all_phases.length / data.expected_steps)));
                            }
                            
                            // Get clean phase name for progress bar
                            let cleanPhaseName = getPhaseStatus(phase);
                            cleanPhaseName = sanitizeAscii(cleanPhaseName);
                            
                            // Special handling for KSMS bulk operations
                            if (phase.startsWith('KSMS_') && details.includes('services')) {
                                // Extract service count from details for KSMS
                                const serviceMatch = details.match(/(\d+)\s+services?/);
                                if (serviceMatch) {
                                    const serviceCount = serviceMatch[1];
                                    if (phase === 'KSMS_BULK_SCAN') {
                                        cleanPhaseName = `Scanning ${serviceCount} services`;
                                    } else if (phase === 'KSMS_FORMAT_RESULTS') {
                                        cleanPhaseName = `Processing ${serviceCount} results`;
                                    }
                                }
                            }
                            
                            // Create detailed message for log window
                            let logMessage = cleanPhaseName;
                            if (details && details.trim()) {
                                logMessage += `: ${sanitizeAscii(details)}`;
                            }
                            // Append live queue position if present (QUEUED only)
                            if (!data.complete && phase === 'QUEUED' && typeof data.queue_position === 'number' && data.queue_position > 0) {
                                logMessage = `In queue position ${data.queue_position}`;
                                cleanPhaseName = `In queue position ${data.queue_position}`;
                            }
                            
                            // Update progress bar with clean name only
                            updateProgress(currentProgress, cleanPhaseName);
                            
                            // Determine log type based on phase
                            let logType = 'info';
                            if (phase === 'COMPLETE' || phase === 'PDF_GEN_TOTAL' || phase === 'TOTAL' || phase === 'KSMS_PDF_GENERATION') {
                                logType = 'success';
                                currentProgress = 100; // Force to 100% on completion
                            } else if (phase.includes('ERROR') || phase.includes('FAIL')) {
                                logType = 'error';
                            }
                            
                            // Add full details to log window
                            addProgressLogEntry(logMessage, logType);
                            
                            
                            // If cancelled/failed, inform user and stop
                            if (phase === 'FAILED' || phase === 'ERROR') {
                                try { eventSource.close(); } catch (e) {}
                                const msg = details || 'Your job was cancelled.';
                                showCancelledModal(sanitizeAscii(msg));
                            }
                            newPhasesProcessed = true;
                        }
                    });
                }
                // If no new phases were processed but server sent a snapshot with a phase, update progress text
                if (!newPhasesProcessed && data.phase) {
                    let cleanPhaseName = sanitizeAscii(getPhaseStatus(data.phase));
                    if (!data.complete && data.phase === 'QUEUED' && typeof data.queue_position === 'number' && data.queue_position > 0) {
                        cleanPhaseName = `In queue position ${data.queue_position}`;
                    }
                    updateProgress(currentProgress, cleanPhaseName);
                }
                
                // Handle completion
                if (data.complete) {
                    // If job failed/cancelled, inform the user and return to form
                    if (data.success === false || (data.phase && (data.phase === 'FAILED' || data.phase === 'ERROR'))) {
                        try { eventSource.close(); } catch (e) {}
                        const msg = sanitizeAscii(data.error || 'Your job was cancelled.');
                        showCancelledModal(msg);
                    } else {
                        lastMilestoneMessage = 'Test complete!';
                        updateProgress(100, lastMilestoneMessage);
                        addProgressLogEntry('Test completed successfully!', 'success');
                        try { eventSource.close(); } catch (e) {}
                        if (data.redirect_url) {
                            pdfRedirectUrl = data.redirect_url;
                            const button = document.getElementById('showPdfButton');
                            button.style.display = 'inline-block';
                            button.disabled = false;
                            button.onclick = function() { window.location.href = pdfRedirectUrl; };
                            addProgressLogEntry('PDF report is ready. Click the button below to view it.', 'success');
                        }
                    }
                }
            } catch (error) {
                console.error('Error parsing SSE data:', error);
            }
        };
        
        eventSource.onerror = function(error) {
            console.error('SSE connection error:', error);
            addProgressLogEntry('Connection lost. Retrying...', 'warning');
            
            // EventSource will automatically reconnect
            // But if we're complete, close it
            if (currentProgress >= 100) {
                eventSource.close();
            }
        };
        
        eventSource.addEventListener('error', function(event) {
            if (event.data) {
                try {
                    const data = JSON.parse(event.data);
                    addProgressLogEntry('Error: ' + data.error, 'error');
                } catch (e) {
                    console.error('Error parsing error event:', e);
                }
            }
            eventSource.close();
        });
    }
    
    // Initial update
    updateProgress(0, 'Initializing...');
    // Sanitize to printable ASCII for UI
    function sanitizeAscii(s) {
        if (!s) return '';
        return s.replace(/[^\x20-\x7E]/g, '');
    }
    
    // Start SSE stream after a short delay to let the test start
    setTimeout(startProgressStream, 1000);

    function showCancelledModal(message) {
        const modal = document.createElement('div');
        modal.className = 'modal';
        modal.style.display = 'block';
        modal.innerHTML = `
            <div class="modal-content">
              <div class="modal-header">
                <h2>Job Cancelled</h2>
              </div>
              <div class="modal-body">
                <p>${message}</p>
              </div>
              <div class="modal-footer">
                <button type="button" onclick="window.location.href='/form.html'">OK</button>
              </div>
            </div>`;
        document.body.appendChild(modal);
    }
    </script>
</body>
</html>

<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="Cache-Control" content="no-cache, no-store, must-revalidate">
  <meta http-equiv="Pragma" content="no-cache">
  <meta http-equiv="Expires" content="0">
  <title>TSIM Queue Admin</title>
  <link rel="stylesheet" href="/css/style.css?v=3">
  <style>
    /* Override container max-width for admin page - allow full width */
    body {
      margin: 0;
      padding: 0;
    }
    .container {
      max-width: none !important;
      width: 100%;
      padding: 20px;
      margin: 0;
    }
    .queue-table {
      width: 100%;
      border-collapse: collapse;
    }
    .queue-table th, .queue-table td {
      border: 1px solid #ddd;
      padding: 8px;
      height: 50px;
      max-height: 50px;
      overflow: hidden;
      vertical-align: middle;
      overflow-wrap: break-word;
      word-break: keep-all;
      white-space: normal;
    }
    .queue-table th { background: #f2f2f2; text-align: left; }
    .status-badge { padding: 2px 6px; border-radius: 4px; background: #eee; }
    .status-cell {
      font-size: 13px;
      line-height: 1.2;
      height: 100%;
      overflow: hidden;
      overflow-wrap: break-word;
      word-break: keep-all;
      white-space: normal;
      display: flex;
      align-items: center;
    }
    .run-id-cell {
      font-family: 'Courier New', Courier, monospace;
      font-weight: bold;
    }
    .progress-bar {
      height: 24px;
      background-color: #4a4a4a;
      border-radius: 12px;
      overflow: hidden;
      position: relative;
      min-width: 120px;
    }
    .progress-fill {
      height: 100%;
      background: linear-gradient(90deg, #3498db, #2980b9);
      border-radius: 12px;
      transition: width 0.3s ease;
    }
    .progress-text {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      color: white;
      font-size: 12px;
      font-weight: bold;
      text-shadow: 1px 1px 2px rgba(0,0,0,0.5);
    }
  </style>
</head>
<body>
  <div class="container">
    <div id="runningPoolContainer" style="margin: 16px 0;">
      <h2>Running Pool (<span id="runningPoolCount">0</span>)</h2>
      <table class="queue-table" id="runningPoolTable">
        <thead><tr><th>Run ID</th><th>User</th><th>Mode</th><th>Services</th><th>DSCP</th><th>Status</th><th>Progress</th><th>Created</th><th>Actions</th></tr></thead>
        <tbody id="runningPoolBody"></tbody>
      </table>
    </div>

    <div id="waitingQueueContainer" style="margin: 16px 0;">
      <h2>Waiting Queue (<span id="waitingQueueCount">0</span>)</h2>
      <table class="queue-table" id="waitingQueueTable">
        <thead><tr><th>Position</th><th>Run ID</th><th>User</th><th>Mode</th><th>Services</th><th>Status</th><th>Created</th><th>Actions</th></tr></thead>
        <tbody id="waitingQueueBody"></tbody>
      </table>
    </div>

    <h2 style="margin-top:24px;">Finished Jobs (<span id="finishedJobsCount">0</span>)</h2>
    <table class="queue-table" id="historyTable">
      <thead>
        <tr>
          <th>Run ID</th>
          <th>User</th>
          <th>Mode</th>
          <th>Status</th>
          <th>Finished</th>
          <th>Actions</th>
        </tr>
      </thead>
      <tbody id="historyBody"></tbody>
    </table>
  </div>

  <script>
    function sanitizeAscii(s){ return (s||'').replace(/[^\x20-\x7E]/g,''); }
    function fmtDate(ts){
      if (ts == null || ts === '') return '';
      let n = Number(ts);
      if (isNaN(n)) return '';
      if (n > 1e12) n = Math.floor(n/1000);
      const d = new Date(n*1000);
      const pad = v => String(v).padStart(2,'0');
      return `${pad(d.getDate())}.${pad(d.getMonth()+1)}.${d.getFullYear()}. ${pad(d.getHours())}:${pad(d.getMinutes())}:${pad(d.getSeconds())}`;
    }
    function getPhaseStatus(phase) {
      const map = {
        'START': 'Starting test',
        'parse_args': 'Validating parameters',
        'QUEUED': 'In queue',
        'WAITING_FOR_ENVIRONMENT': 'Waiting for simulator to be available',
        'TRACE_COMPLETE': 'Trace execution completed',
        'SERVICE_TESTS': 'Testing services',
        'PDF_GENERATION': 'Generating PDF report',
        'PHASE1_start': 'Initializing path discovery',
        'PHASE1_path_discovery': 'Discovering network path',
        'PHASE1_trace_load': 'Loading trace data',
        'PHASE1_trace_complete': 'Trace completed',
        'PHASE1_complete': 'Path discovery complete',
        'PHASE2_start': 'Setting up environment',
        'PHASE2_host_list': 'Checking existing hosts',
        'PHASE2_host_setup_start': 'Setting up test hosts',
        'PHASE2_hosts_complete': 'Hosts configured',
        'PHASE2_service_check': 'Checking services',
        'PHASE2_services_start': 'Starting services',
        'PHASE2_complete': 'Environment ready',
        'PHASE3_start': 'Starting reachability tests',
        'PHASE3_complete': 'Initial tests complete',
        'PHASE4_start': 'Testing services',
        'PHASE4_complete': 'Service tests complete',
        'PHASE5_format_output': 'Formatting results',
        'PHASE5_complete': 'Results formatted',
        'TOTAL': 'Test execution complete',
        'COMPLETE': 'Test complete!',
        'ERROR': 'Error occurred',
        'FAIL': 'Test failed',
        'FAILED': 'Cancelled',
        
        // KSMS Quick Analysis phases
        'KSMS_QUICK_START': 'Starting quick analysis',
        'KSMS_BULK_SCAN': 'Executing bulk service scan',
        'KSMS_FORMAT_RESULTS': 'Processing scan results',
        'KSMS_PDF_GENERATION': 'Generating summary report'
      };
      return map[phase] || phase;
    }

    function adjustFontSize(element) {
      if (!element) return;

      // Start with default font size
      let fontSize = 13;
      const minFontSize = 5; // Allow very small fonts to fit all text
      const maxHeight = 42; // Cell padding leaves ~42px for content

      element.style.fontSize = fontSize + 'px';
      element.style.whiteSpace = 'normal'; // Allow wrapping
      element.style.lineHeight = '1.2';

      // Keep reducing font size until text fits (no ellipsis - show full text)
      let iterations = 0;
      const maxIterations = 50; // Prevent infinite loops

      while (element.scrollHeight > maxHeight && fontSize > minFontSize && iterations < maxIterations) {
        fontSize -= 0.3;
        element.style.fontSize = fontSize + 'px';
        iterations++;
      }

      // If still overflowing after reaching minimum size, try tighter line height
      if (element.scrollHeight > maxHeight && fontSize <= minFontSize) {
        let lineHeight = 1.2;
        while (element.scrollHeight > maxHeight && lineHeight > 1.0 && iterations < maxIterations) {
          lineHeight -= 0.05;
          element.style.lineHeight = lineHeight.toFixed(2);
          iterations++;
        }
      }
    }

    function startStream(){
      const es = new EventSource('/admin-queue-stream');
      es.onmessage = function(event){
        const data = JSON.parse(event.data || '{}');

        // Helper function to format services with port range compression
        function formatServices(params) {
          const portList = params.port_protocol_list || [];
          if (!Array.isArray(portList) || portList.length === 0) return '';

          // Group ports by protocol
          const byProtocol = {};
          portList.forEach(([port, protocol]) => {
            if (!byProtocol[protocol]) byProtocol[protocol] = [];
            byProtocol[protocol].push(port);
          });

          // Format each protocol group with range compression
          const parts = [];
          for (const protocol in byProtocol) {
            const ports = byProtocol[protocol].sort((a, b) => a - b);
            const ranges = [];
            let start = ports[0];
            let end = ports[0];

            for (let i = 1; i <= ports.length; i++) {
              if (i < ports.length && ports[i] === end + 1) {
                end = ports[i];
              } else {
                if (start === end) {
                  ranges.push(`${start}`);
                } else if (end === start + 1) {
                  ranges.push(`${start}`, `${end}`);
                } else {
                  ranges.push(`${start}-${end}`);
                }
                if (i < ports.length) {
                  start = ports[i];
                  end = ports[i];
                }
              }
            }

            parts.push(ranges.join(',') + '/' + protocol);
          }

          return parts.join(', ');
        }

        // Display Running Pool (actually executing jobs)
        const runningPool = data.running_pool || [];
        const rpBody = document.getElementById('runningPoolBody');
        document.getElementById('runningPoolCount').textContent = runningPool.length;
        rpBody.innerHTML = '';

        runningPool.forEach(job => {
          if (!job || !job.run_id) return;

          const tr = document.createElement('tr');
          const percent = Math.max(0, Math.min(100, parseInt(job.percent || 0)));
          // Use phase_message (user-friendly) instead of mapped phase name
          const statusMessage = sanitizeAscii(job.phase_message || getPhaseStatus(job.phase || 'RUNNING'));
          const created = fmtDate(job.created_at);

          const params = job.params || {};
          const analysisMode = params.analysis_mode || params.mode || 'unknown';
          const modeDisplay = analysisMode === 'quick' ? 'Quick' : (analysisMode === 'detailed' ? 'Detailed' : analysisMode);
          const dscpDisplay = job.dscp_value ? `${job.dscp_value}` : 'N/A';
          const services = formatServices(params);

          // Create progress bar HTML matching user interface
          const progressBarHtml = `<div class="progress-bar"><div class="progress-fill" style="width: ${percent}%"></div><div class="progress-text">${percent}%</div></div>`;

          tr.innerHTML = `<td class="run-id-cell">${sanitizeAscii(job.run_id||'')}</td>` +
                        `<td>${sanitizeAscii(job.username||'')}</td>` +
                        `<td>${modeDisplay}</td>` +
                        `<td>${sanitizeAscii(services)}</td>` +
                        `<td>${dscpDisplay}</td>` +
                        `<td><div class="status-cell" data-text="${sanitizeAscii(statusMessage)}">${statusMessage}</div></td>` +
                        `<td>${progressBarHtml}</td>` +
                        `<td>${created}</td>` +
                        `<td><button data-run-id="${sanitizeAscii(job.run_id||'')}" class="force-cancel-btn" style="background: #d9534f; color: white; border: none; padding: 4px 8px; cursor: pointer; border-radius: 3px;">Cancel</button></td>`;
          rpBody.appendChild(tr);

          // Adjust font size if text overflows
          adjustFontSize(tr.querySelector('.status-cell'));
        });

        // Add force cancel handlers for running jobs
        document.querySelectorAll('.force-cancel-btn').forEach(btn => {
          btn.onclick = async () => {
            const runId = btn.getAttribute('data-run-id');
            if (!runId) return;
            if (!confirm(`Force cancel running job ${runId}?\n\nThis will:\n- Remove the job from the running pool\n- Release allocated resources (DSCP)\n- Mark the job as failed\n\nUse this for stuck or zombie jobs.`)) return;
            btn.disabled = true;
            btn.textContent = 'Cancelling...';
            try {
              const fd = new FormData();
              fd.append('action', 'force_cancel');
              fd.append('run_id', runId);
              const resp = await fetch('/admin-queue', { method: 'POST', body: fd, headers: { 'X-Requested-With': 'XMLHttpRequest' } });
              const result = await resp.json();
              if (result.success) {
                alert(`Job ${runId} was successfully cancelled`);
              } else {
                alert(`Failed to cancel job: ${result.message || 'Unknown error'}`);
                btn.disabled = false;
                btn.textContent = 'Cancel';
              }
            } catch (e) {
              alert(`Error cancelling job: ${e.message}`);
              btn.disabled = false;
              btn.textContent = 'Cancel';
            }
          };
        });

        // Display Waiting Queue (scheduler queue + thread pool queue)
        const waitingQueue = data.waiting_queue || [];
        const wqBody = document.getElementById('waitingQueueBody');
        document.getElementById('waitingQueueCount').textContent = waitingQueue.length;
        wqBody.innerHTML = '';

        waitingQueue.forEach((job, idx) => {
          if (!job || !job.run_id) return;

          const tr = document.createElement('tr');
          const created = fmtDate(job.created_at);
          const params = job.params || {};
          const services = formatServices(params);
          const queueMode = params.analysis_mode || 'detailed';
          const queueModeDisplay = queueMode === 'quick' ? 'Quick' : 'Detailed';
          const status = job.status || 'WAITING';

          tr.innerHTML = `<td>${idx + 1}</td>`+
                         `<td class="run-id-cell">${sanitizeAscii(job.run_id||'')}</td>`+
                         `<td>${sanitizeAscii(job.username||'')}</td>`+
                         `<td>${queueModeDisplay}</td>`+
                         `<td>${sanitizeAscii(services)}</td>`+
                         `<td><span class=\"status-badge\">${sanitizeAscii(status)}</span></td>`+
                         `<td>${created}</td>`+
                         `<td><button data-run-id=\"${sanitizeAscii(job.run_id||'')}\" class=\"cancel-btn\">Cancel</button></td>`;
          wqBody.appendChild(tr);
        });
        document.querySelectorAll('.cancel-btn').forEach(btn => {
          btn.onclick = async () => {
            const runId = btn.getAttribute('data-run-id');
            if (!runId) return;
            if (!confirm(`Cancel ${runId}?`)) return;
            const fd = new FormData();
            fd.append('action', 'cancel');
            fd.append('run_id', runId);
            await fetch('/admin-queue', { method: 'POST', body: fd, headers: { 'X-Requested-With': 'XMLHttpRequest' } });
          };
        });
        // Populate history
        const hbody = document.getElementById('historyBody');
        if (hbody) {
          hbody.innerHTML = '';
          const history = data.history || [];
          document.getElementById('finishedJobsCount').textContent = history.length;
          history.forEach(item => {
            const tr = document.createElement('tr');
            const finished = fmtDate(item.finished_at);
            let status = item.status || (item.success ? 'SUCCESS' : 'FAILED');
            if (status === 'FAILED' && (item.cancelled_by || item.cancelled_at)) {
              status = 'CANCELLED';
            }
            const runId = sanitizeAscii(item.run_id||'');
            const histParams = item.params || {};
            const historyMode = histParams.analysis_mode || histParams.mode || 'detailed';
            const historyModeDisplay = historyMode === 'quick' ? 'Quick' : 'Detailed';
            tr.innerHTML = `<td class="run-id-cell">${runId}</td>`+
                           `<td>${sanitizeAscii(item.username||'')}</td>`+
                           `<td>${historyModeDisplay}</td>`+
                           `<td>${sanitizeAscii(status)}</td>`+
                           `<td>${finished}</td>`+
                           `<td><button class=\"details-btn\" data-run-id=\"${runId}\">Details</button></td>`;
            hbody.appendChild(tr);
          });
          document.querySelectorAll('.details-btn').forEach(btn => {
            btn.onclick = () => {
              const rid = btn.getAttribute('data-run-id');
              if (rid) window.open(`/admin_job.html?id=${rid}`, '_blank');
            };
          });
        }
      };
      es.onerror = function(e){ console.debug('admin-queue stream error', e); };
    }
    startStream();
  </script>
</body>
</html>

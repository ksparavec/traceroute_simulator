<!DOCTYPE html>
<html>
<head>
    <title>Test in Progress - Network Reachability</title>
    <link rel="stylesheet" href="/css/style.css">
</head>
<body>
    <div class="container">
        <header>
            <h1>Network Reachability Test in Progress</h1>
        </header>
        
        <div class="progress-container">
            <div class="progress-bar">
                <div id="progressBar" class="progress-fill" style="width: 0%"></div>
                <div class="progress-text" id="progressText">Initializing test...</div>
            </div>
            <div class="progress-percentage">
                <span id="progressPercent">0</span>%
            </div>
        </div>
        
        <div class="progress-log">
            <div id="progressLog"></div>
        </div>
        
        <div style="text-align: center; margin-top: 20px;">
            <button id="showPdfButton" style="display: none; padding: 12px 24px; font-size: 16px; background-color: #3498db; color: white; border: none; border-radius: 4px; cursor: pointer; transition: background-color 0.3s;" 
                    onmouseover="this.style.backgroundColor='#2980b9'" 
                    onmouseout="this.style.backgroundColor='#3498db'" 
                    disabled>
                Show PDF Report
            </button>
        </div>
    </div>

    <script>
    // Get parameters from URL
    const urlParams = new URLSearchParams(window.location.search);
    const runId = urlParams.get('run_id');
    const sessionId = urlParams.get('session');
    
    // Simple progress tracking - just increment by 2% for each new entry
    const PROGRESS_INCREMENT = 2;
    
    // Track progress
    let currentProgress = 0;
    let processedPhases = new Set();
    let firstCheckDone = false;
    let pdfRedirectUrl = null;
    let lastMilestoneMessage = 'Initializing...';  // Keep track of last milestone
    
    function updateProgress(percent, status) {
        // Update progress bar - always use the provided percent value
        document.getElementById('progressBar').style.width = percent + '%';
        document.getElementById('progressPercent').textContent = Math.round(percent);
        
        // Only update text if status is provided
        if (status !== null && status !== undefined) {
            document.getElementById('progressText').textContent = status;
        }
    }
    
    function addProgressLogEntry(message, type = 'info') {
        const logDiv = document.getElementById('progressLog');
        const entry = document.createElement('div');
        entry.className = `progress-log-entry ${type}`;
        const timestamp = new Date().toLocaleTimeString();
        entry.textContent = `[${timestamp}] ${message}`;
        logDiv.appendChild(entry);
        logDiv.scrollTop = logDiv.scrollHeight;
    }
    
    function getPhaseStatus(phase) {
        // Generate human-readable status from phase name
        const statusMap = {
            'START': 'Starting test',
            'parse_args': 'Validating parameters',
            'PHASE1_path_discovery': 'Discovering network path',
            'PHASE1_complete': 'Path discovery complete',
            'PHASE2_host_list': 'Checking existing hosts',
            'PHASE2_host_setup_start': 'Setting up test hosts',
            'host_add_source': 'Adding source host',
            'host_add_destination': 'Adding destination host',
            'PHASE2_hosts_complete': 'Hosts configured',
            'PHASE2_service_check': 'Checking services',
            'PHASE2_service_start': 'Starting service',
            'PHASE2_service_exists': 'Service ready',
            'PHASE2_complete': 'Environment ready',
            'PHASE3_tests_start': 'Starting connectivity tests',
            'ping': 'Running ping test',
            'traceroute': 'Running traceroute',
            'service_test': 'Testing service',
            'PHASE3_tests_complete': 'Tests completed',
            'PHASE3_complete': 'Test analysis complete',
            'PHASE4_packet_analysis': 'Analyzing packets',
            'PHASE4_complete': 'Packet analysis complete',
            'PHASE5_format_output': 'Formatting results',
            'PHASE5_complete': 'Report ready',
            'TOTAL': 'Reachability test complete',
            'PDF_GEN_PARSE_START': 'Starting PDF generation',
            'PDF_GEN_parse_params': 'Processing parameters',
            'PDF_GEN_validate_params': 'Validating parameters',
            'PDF_GEN_venv_activate': 'Activating environment',
            'PDF_GEN_visualize_reachability.py': 'Generating PDF report',
            'PDF_GEN_TOTAL': 'PDF generation complete',
            'PDF_GENERATION': 'Generating PDF report',
            'PDF_COMPLETE': 'PDF ready',
            'COMPLETE': 'Test complete!'
        };
        
        return statusMap[phase] || phase.replace(/_/g, ' ');
    }
    
    function checkProgress() {
        if (!runId) {
            addProgressLogEntry('Error: No run ID provided', 'error');
            return;
        }
        
        fetch(`/cgi-bin/get_progress.py?run_id=${runId}&session=${sessionId}`)
            .then(response => response.json())
            .then(data => {
                // Debug logging - but suppress "No entries found" for the first 3 seconds
                if (data.debug_error) {
                    if (!firstCheckDone && data.debug_error.includes('No entries found')) {
                        // Suppress this error for initial checks
                        console.log('Waiting for test to start...');
                    } else {
                        console.error('Progress tracking error:', data.debug_error);
                        addProgressLogEntry('Debug: ' + data.debug_error, 'error');
                    }
                }
                firstCheckDone = true;
                
                if (data.all_phases && data.all_phases.length > 0) {
                    console.log('Received phases:', data.all_phases);
                } else if (firstCheckDone) {
                    console.log('No phases received yet. Run ID:', runId);
                }
                
                // Process all phases that have been seen
                if (data.all_phases && data.all_phases.length > 0) {
                    data.all_phases.forEach(phaseInfo => {
                        // Handle both old format (string) and new format (object)
                        const phase = typeof phaseInfo === 'string' ? phaseInfo : phaseInfo.phase;
                        const details = typeof phaseInfo === 'object' ? phaseInfo.details : '';
                        
                        // Phases are already filtered on server side
                        
                        const phaseKey = `${phase}|${details}`; // Unique key including details
                        if (!processedPhases.has(phaseKey)) {
                            processedPhases.add(phaseKey);
                            
                            // Increment progress by 2% for each new entry (cap at 100%)
                            currentProgress = Math.min(currentProgress + PROGRESS_INCREMENT, 100);
                            
                            // Show ALL progress entries with details
                            let messageToShow = getPhaseStatus(phase);
                            if (details && details.trim()) {
                                messageToShow += `: ${details}`;
                            }
                            
                            // Update progress bar and log
                            updateProgress(currentProgress, messageToShow);
                            
                            // Determine log type based on phase
                            let logType = 'info';
                            if (phase === 'COMPLETE' || phase === 'PDF_GEN_TOTAL' || phase === 'TOTAL') {
                                logType = 'success';
                                currentProgress = 100; // Force to 100% on completion
                            } else if (phase.includes('ERROR') || phase.includes('FAIL')) {
                                logType = 'error';
                            }
                            
                            addProgressLogEntry(messageToShow, logType);
                        }
                    });
                }
                
                // Handle current phase - but don't override milestone messages
                // This is handled above in all_phases processing
                
                // Handle completion
                if (data.complete) {
                    lastMilestoneMessage = 'Test complete!';
                    updateProgress(100, lastMilestoneMessage);
                    addProgressLogEntry('Test completed successfully!', 'success');
                    
                    // Clear the interval
                    clearInterval(progressInterval);
                    
                    // Store redirect URL and show button
                    if (data.redirect_url) {
                        pdfRedirectUrl = data.redirect_url;
                        const button = document.getElementById('showPdfButton');
                        button.style.display = 'inline-block';
                        button.disabled = false;
                        button.onclick = function() {
                            window.location.href = pdfRedirectUrl;
                        };
                        addProgressLogEntry('PDF report is ready. Click the button below to view it.', 'success');
                    }
                }
            })
            .catch(error => {
                console.error('Progress check error:', error);
            });
    }
    
    // Initial update
    updateProgress(0, 'Initializing...');
    
    // Check progress every 2 seconds
    const progressInterval = setInterval(checkProgress, 2000);
    
    // First check after 2 seconds (give test time to start)
    setTimeout(checkProgress, 2000);
    </script>
</body>
</html>